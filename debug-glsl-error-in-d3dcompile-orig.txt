#line 86 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif

#include "HLSLSupport.cginc"
#include "UnityShaderVariables.cginc"
#line 86 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif

		// #pragma vertex VertShader
		// #pragma fragment PixShader
		// #pragma fragmentoption ARB_precision_hint_fastest
		// #pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER
		// #pragma shader_feature __ MASK_HARD MASK_SOFT		

		#include "UnityCG.cginc"

		#include "TMPro_Properties.cginc" 

		struct vertex_t {
			float4	vertex			: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float2	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t {
			float4	vertex			: SV_POSITION;
			fixed4	faceColor		: COLOR;
			fixed4	outlineColor	: COLOR1;
			float2	texcoord0		: TEXCOORD0;
			half4	param			: TEXCOORD1;			// Scale(x), BiasIn(y), BiasOut(z), Bias(w)
			half4	mask			: TEXCOORD2;			// Position(xy) in object space, pixel Size(zw) in screen space
		#if (UNDERLAY_ON | UNDERLAY_INNER)
			float2	texcoord1		: TEXCOORD3;
			fixed4	underlayColor	: TEXCOORD4;
			half2	underlayParam	: TEXCOORD5;			// Scale(x), Bias(y)
		#endif
		};

		fixed _ForwardThreshold;
        fixed _BackThreshold;

		pixel_t VertShader(vertex_t input)
		{
			float bold = step(input.texcoord1.y, 0);

			float4 vert = input.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;
			float4 vPosition = mul(UNITY_MATRIX_MVP, vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));
			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord1.y) * _GradientScale * 1.5;
			if(UNITY_MATRIX_P[3][3] == 0) scale = lerp(scale*(1-_PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / _GradientScale;
			weight += _FaceDilate * _ScaleRatioA * 0.5;

			float layerScale = scale;

			scale /= 1 + (_OutlineSoftness * _ScaleRatioA * scale);
			float bias = (0.5 - weight) * scale - 0.5;
			float outline = _OutlineWidth * _ScaleRatioA * 0.5 * scale;

			float opacity = input.color.a;
			fixed4 faceColor = fixed4(input.color.rgb, opacity)*_FaceColor;
			fixed4 outlineColor = _OutlineColor;
			faceColor.rgb *= faceColor.a;
			outlineColor.a *= opacity;
			outlineColor.rgb *= outlineColor.a;
			outlineColor = lerp(faceColor, outlineColor, sqrt(min(1.0, (outline * 2))));

		#if (UNDERLAY_ON | UNDERLAY_INNER)
			float4 layerColor = _UnderlayColor;
			layerColor.a *= opacity;
			layerColor.rgb *= layerColor.a;

			layerScale /= 1 + ((_UnderlaySoftness * _ScaleRatioC) * layerScale);
			float layerBias = (.5 - weight) * layerScale - .5 - ((_UnderlayDilate * _ScaleRatioC) * .5 * layerScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 layerOffset = float2(x, y);

		#endif

			pixel_t output = {
				vPosition,
				faceColor,
				outlineColor,
				input.texcoord0,
				half4(scale, bias - outline, bias + outline, bias),
//				half4(vert.xy, .5 / pixelSize.xy),
				vert.xywz,
			#if (UNDERLAY_ON | UNDERLAY_INNER)
				input.texcoord0 + layerOffset,
				layerColor,
				half2(layerScale, layerBias),
			#endif
			};

			return output;
		}

		fixed4 PixShader(pixel_t input) : COLOR
		{
			half d = tex2D(_MainTex, input.texcoord0).a * input.param.x;
			half sd = saturate(d - input.param.z);
			fixed4 c = lerp(input.outlineColor, input.faceColor, saturate(d - input.param.z));
			c *= saturate(d - input.param.y);

		#if UNDERLAY_ON
			d = tex2D(_MainTex, input.texcoord1).a * input.underlayParam.x;
			c += input.underlayColor * (saturate(d - input.underlayParam.y) * (1-c.a));
		#endif

		#if UNDERLAY_INNER
			d = tex2D(_MainTex, input.texcoord1).a * input.underlayParam.x;
			c += input.underlayColor * (1 - saturate(d - input.underlayParam.y)) * sd * (1 - c.a);
		#endif

		half m = step(input.mask.x, _ForwardThreshold) * step(_BackThreshold, input.mask.x);
		c *= m;

		#if MASK_SOFT
			half2 s = half2(_MaskSoftnessX, _MaskSoftnessY) * input.mask.zw;
			half2 m = 1 - saturate(((abs(input.mask.xy) - _MaskCoord.zw) * input.mask.zw + s) / (1 + s));
			m *= m;
			c *= m.x * m.y;			
		#endif

			return c;
		}
		